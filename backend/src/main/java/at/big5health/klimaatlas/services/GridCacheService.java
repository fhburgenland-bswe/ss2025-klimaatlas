package at.big5health.klimaatlas.services;

import at.big5health.klimaatlas.dtos.WeatherReportDTO;
import at.big5health.klimaatlas.grid.BoundingBox;
import at.big5health.klimaatlas.grid.GridCellInfo;
import at.big5health.klimaatlas.grid.GridUtil;
import at.big5health.klimaatlas.grid.GridTemperature;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import lombok.AllArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Service responsible for managing and caching temperature grid data for various Austrian states.
 * <p>
 * This service initializes a cache with temperature data for predefined grid points upon
 * application startup ({@link PostConstruct @PostConstruct}). The cache is periodically
 * refreshed using a scheduled task ({@link Scheduled @Scheduled}).
 * It utilizes an {@link ExecutorService} for parallel data fetching during initialization
 * and interacts with {@link WeatherService} to get temperature data for individual grid points.
 * <p>
 * Dependencies are injected via the constructor generated by Lombok's
 * {@link AllArgsConstructor @AllArgsConstructor}.
 * Cached data is stored under the "temperatureGrid" cache, keyed by state name.
 *
 * @see WeatherService
 * @see GridUtil
 * @see BoundingBox
 */
@Service
@AllArgsConstructor
public class GridCacheService {

    private static final Logger LOGGER = LoggerFactory.getLogger(GridCacheService.class);


    /**
     * Service used to fetch detailed weather reports for specific coordinates and dates.
     * Injected via constructor by Lombok's {@link AllArgsConstructor @AllArgsConstructor}.
     */
    protected final WeatherService weatherService;
    /**
     * Utility class for generating grid cells based on bounding boxes and resolution.
     * Injected via constructor by Lombok's {@link AllArgsConstructor @AllArgsConstructor}.
     */
    protected final GridUtil gridUtil;
    /**
     * Spring's CacheManager for interacting with the underlying cache programmatically.
     * Injected via constructor by Lombok's {@link AllArgsConstructor @AllArgsConstructor}.
     */
    private final CacheManager cacheManager;

    /**
     * Defines the geographical bounding boxes for the Austrian states.
     * Used to determine the grid points for which to fetch temperature data.
     * The keys are state names (e.g., "Wien", "Tirol").
     */
    private final Map<String, BoundingBox> austrianStates = new HashMap<String, BoundingBox>() {{
        put("Niederösterreich", new BoundingBox(47.4, 48.7, 14.4, 17.2));
        put("Wien", new BoundingBox(48.1, 48.3, 16.2, 16.6));
        put("Burgenland", new BoundingBox(46.7, 48.1, 16.0, 17.2));
        put("Steiermark", new BoundingBox(46.6, 47.9, 13.6, 16.2));
        put("Oberösterreich", new BoundingBox(47.4, 48.8, 12.7, 14.9));
        put("Salzburg", new BoundingBox(46.8, 47.9, 12.5, 13.8));
        put("Kärnten", new BoundingBox(46.4, 47.2, 12.6, 15.0));
        put("Tirol", new BoundingBox(46.6, 47.8, 10.0, 13.0));
        put("Vorarlberg", new BoundingBox(46.8, 47.6, 9.5, 10.3));
    }};

    /**
     * Thread pool for executing asynchronous tasks, primarily for parallel
     * fetching of temperature data during cache initialization.
     */
    private final ExecutorService executorService = Executors.newFixedThreadPool(4);

    /**
     * Initializes the temperature grid cache for all predefined Austrian states.
     * <p>
     * This method is automatically invoked by Spring after bean construction due to
     * the {@link PostConstruct @PostConstruct} annotation. It fetches temperature data
     * for each state in parallel using the {@link #executorService}.
     * If fetching data for a state fails, an error is logged, but initialization
     * continues for other states.
     */
    @PostConstruct
    public void initializeGridCache() {
        LOGGER.info("Initializing temperature grid cache for all Austrian states");

        List<CompletableFuture<Void>> futures = new ArrayList<>();

        for (Map.Entry<String, BoundingBox> state : austrianStates.entrySet()) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                try {
                    LOGGER.info("Loading temperature grid for state: {}", state.getKey());
                    getTemperatureGridForState(state.getKey());
                    LOGGER.info("Successfully loaded temperature grid for state: {}", state.getKey());
                } catch (Exception e) {
                    LOGGER.error("Failed to load temperature grid for state: {}", state.getKey(), e);
                }
            }, executorService);

            futures.add(future);
        }

        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        LOGGER.info("Temperature grid cache initialization completed");
    }
    /**
     * Refreshes the entire temperature grid cache once a day at a set time.
     * <p>
     * This method is scheduled to run daily at 10:00 AM, as defined by the CRON expression
     * in the {@link Scheduled @Scheduled} annotation. It evicts all entries from the
     * "temperatureGrid" cache using {@link CacheEvict @CacheEvict} and then
     * re-initializes the cache by calling {@link #initializeGridCache()}.
     */
    @Scheduled(cron = "0 0 10 * * ?")
    @CacheEvict(value = "temperatureGrid", allEntries = true)
    public void refreshCache() {
        LOGGER.info("Refreshing temperature grid cache");
        initializeGridCache();
    }

    /**
     * Retrieves a list of temperature grid points for a specified Austrian state.
     * <p>
     * Results are cached under the "temperatureGrid" cache, with the {@code stateName}
     * serving as the cache key. If data for the state is not in the cache, this method
     * generates grid cells, fetches weather data for each cell using {@link WeatherService},
     * calculates the average temperature, and stores the results in the cache.
     *
     * @param stateName The name of the Austrian state (e.g., "Wien", "Tirol") for which
     *                  to retrieve temperature grid data. Must be a known state.
     * @return A list of {@link GridTemperature} objects for the specified state.
     *         Returns an empty list if no grid points could be processed or if weather data
     *         could not be fetched for any points, but logs warnings for individual failures.
     * @throws IllegalArgumentException if the {@code stateName} is not a recognized state.
     * @see Cacheable
     * @see GridTemperature
     * @see BoundingBox
     * @see GridUtil#generateGrid(BoundingBox, double)
     */
    @Cacheable(value = "temperatureGrid", key = "#stateName")
    public List<GridTemperature> getTemperatureGridForState(String stateName) {
        BoundingBox boundingBox = austrianStates.get(stateName);
        if (boundingBox == null) {
            throw new IllegalArgumentException("Unknown state: " + stateName);
        }

        double gridResolution = 0.1;
        List<GridCellInfo> gridCells = gridUtil.generateGrid(boundingBox, gridResolution);

        List<GridTemperature> gridTemperatures = new ArrayList<>();
        LocalDate today = LocalDate.now();

        for (GridCellInfo cell : gridCells) {
            try {

                double lat = cell.getTargetLatitude();
                double lon = cell.getTargetLongitude();

                WeatherReportDTO report = weatherService.getWeather(null, lon, lat, today);

                Double temperature = null;
                if (report.getMinTemp() != null && report.getMaxTemp() != null) {
                    temperature = (report.getMinTemp() + report.getMaxTemp()) / 2.0;
                } else if (report.getMaxTemp() != null) {
                    temperature = report.getMaxTemp();
                } else if (report.getMinTemp() != null) {
                    temperature = report.getMinTemp();
                }

                if (temperature != null) {
                    gridTemperatures.add(new GridTemperature(
                            cell.getTargetLatitude(),
                            cell.getTargetLongitude(),
                            temperature));
                }
            } catch (Exception e) {
                LOGGER.warn("Could not fetch temperature data for point {}, {}",
                        cell.getTargetLatitude(), cell.getTargetLongitude(), e);
            }
        }

        return gridTemperatures;
    }

    /**
     * Retrieves all cached temperature grid points for all known Austrian states.
     * <p>
     * This method iterates through all predefined states, attempts to retrieve their
     * temperature grid data directly from the "temperatureGrid" cache, and aggregates
     * the results. If data for a particular state is not found in the cache, a warning
     * is logged, and that state's data is omitted from the result.
     *
     * @return A list containing all {@link GridTemperature} objects currently available
     *         in the cache across all states. The list may be empty if the cache is empty
     *         or if no data could be retrieved.
     * @see CacheManager
     */
    public List<GridTemperature> getAllTemperatureGridPoints() {
        List<GridTemperature> allPoints = new ArrayList<>();

        for (String state : austrianStates.keySet()) {
            List cached = cacheManager.getCache("temperatureGrid")
                    .get(state, List.class);
            if (cached != null) {
                allPoints.addAll(cached);
            } else {
                LOGGER.warn("No cached temperature grid for state: {}", state);
            }
        }
        return allPoints;

    }

    /**
     * Shuts down the internal {@link ExecutorService} when the application context is destroyed.
     * <p>
     * This method is automatically invoked by Spring before the bean is destroyed due to
     * the {@link PreDestroy @PreDestroy} annotation, ensuring graceful shutdown of
     * the thread pool.
     */
    @PreDestroy
    public void shutdown() {
        executorService.shutdown();
    }
}